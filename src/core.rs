/// The main hash code used by Starknet.
///
/// Contains 251 bits of data and is generated by the pedersen hash function.
#[derive(Clone, Debug, PartialEq)]
pub struct StarkHash([u8; 32]);

/// Error returned by [StarkHash::from_hex_str]
#[derive(Debug, PartialEq, Clone, Copy)]
pub enum HexParseError {
    /// Hex-string contained a non-hex character.
    InvalidNibble(char),
    /// Hex-string contained more than 251 bits of data.
    Overflow,
}

impl StarkHash {
    /// Parses a hex string into a [StarkHash].
    ///
    /// Supports the following:
    ///     - optional "0x" prefix
    ///     - upper and lower case ('A'-'F' and 'a'-'f').
    ///     - odd nibbles (e.g. 0x123 == 0x0123)
    ///     - short sequences (less than 64 nibbles)
    ///     - leading zeros
    ///
    /// Returns [HexParseError::InvalidNibble] if the sequence contains a non-hex
    /// character.
    ///
    /// Returns [HexParseError::Overflow] if the sequence exceeds 251 bits of data.
    pub fn from_hex_str(hex_str: &str) -> Result<Self, HexParseError> {
        let hex_str = hex_str.strip_prefix("0x").unwrap_or(hex_str);
        if hex_str.len() > 64 {
            return Err(HexParseError::Overflow);
        }

        let mut buf = [0u8; 32];

        // We want the result in big-endian so reverse iterate over each pair of nibbles.
        let chunks = hex_str.as_bytes().rchunks_exact(2);

        // Handle a possible odd nibble remaining nibble.
        let odd_nibble = chunks.remainder();
        if !odd_nibble.is_empty() {
            let full_bytes = hex_str.len() / 2;
            buf[31 - full_bytes] = parse_hex_digit(odd_nibble[0])?;
        }

        for (i, c) in chunks.enumerate() {
            // Indexing c[0] and c[1] are safe since chunk-size is 2.
            buf[31 - i] = parse_hex_digit(c[0])? << 4 | parse_hex_digit(c[1])?;
        }

        // Only 251 bits are allowed to be used.
        if buf[0] & 0b1111_1000 > 0 {
            return Err(HexParseError::Overflow);
        }

        Ok(Self(buf))
    }

    /// Returns the big-endian representation of this [StarkHash].
    pub fn to_be_bytes(self) -> [u8; 32] {
        self.0
    }

    /// Creates a [StarkHash] from big-endian bytes.
    ///
    /// #### Warning: does not check that only 251 bits are set!
    pub fn from_be_bytes(bytes: [u8; 32]) -> Self {
        Self(bytes)
    }
}

/// Parses a hex character. Supports upper and lower case.
///
/// Returns [HexParseError::InvalidNibble] if it is not a hex-character.
fn parse_hex_digit(nibble: u8) -> Result<u8, HexParseError> {
    match nibble {
        b'0'..=b'9' => Ok(nibble - b'0'),
        b'a'..=b'f' => Ok(nibble - b'a' + 10),
        b'A'..=b'F' => Ok(nibble - b'A' + 10),
        other => Err(HexParseError::InvalidNibble(other as char)),
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    mod hex_nibble_to_u8 {
        use super::*;
        use pretty_assertions::assert_eq;

        #[test]
        fn digits() {
            let expected = (0..=9).collect::<Vec<_>>();
            let result = (b'0'..=b'9')
                .map(|c| parse_hex_digit(c).unwrap())
                .collect::<Vec<_>>();

            assert_eq!(result, expected);
        }

        #[test]
        fn lower() {
            let expected = (10..=15).collect::<Vec<_>>();
            let result = (b'a'..=b'f')
                .map(|c| parse_hex_digit(c as u8).unwrap())
                .collect::<Vec<_>>();

            assert_eq!(result, expected);
        }

        #[test]
        fn upper() {
            let expected = (10..=15).collect::<Vec<_>>();
            let result = (b'A'..=b'F')
                .map(|c| parse_hex_digit(c as u8).unwrap())
                .collect::<Vec<_>>();

            assert_eq!(result, expected);
        }

        #[test]
        fn nonhex() {
            assert_eq!(
                parse_hex_digit(b'g'),
                Err(HexParseError::InvalidNibble('g'))
            );
            assert_eq!(
                parse_hex_digit(b'z'),
                Err(HexParseError::InvalidNibble('z'))
            );
            assert_eq!(
                parse_hex_digit(b'0' - 1),
                Err(HexParseError::InvalidNibble((b'0' - 1) as char))
            );
            assert_eq!(
                parse_hex_digit(b'A' - 1),
                Err(HexParseError::InvalidNibble((b'A' - 1) as char))
            );
        }
    }

    mod stark_hash {
        use super::*;

        mod serde {
            use crate::core::StarkHash;

            #[test]
            fn round_trip() {
                let expected = [
                    0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89,
                    0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23,
                    0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
                ];

                let hash = StarkHash::from_be_bytes(expected);
                let bytes = hash.to_be_bytes();
                assert_eq!(bytes, expected);
            }
        }

        mod from_hex_str {
            use super::*;
            use pretty_assertions::assert_eq;

            /// Tests that [StarkHash::from_hex_str] returns the expected result.
            ///
            /// Repeats this test both with and without a "0x" prefix.
            fn run_test_case(test_str: &str, expected: Result<StarkHash, HexParseError>) {
                let without_prefix = StarkHash::from_hex_str(test_str);
                assert_eq!(without_prefix, expected);

                let with_prefix = StarkHash::from_hex_str(&format!("0x{}", test_str));
                assert_eq!(with_prefix, expected);
            }

            #[test]
            fn empty() {
                run_test_case("", Ok(StarkHash([0; 32])));
            }

            #[test]
            fn all_zeros() {
                run_test_case(&"0".repeat(64), Ok(StarkHash([0; 32])));
            }

            #[test]
            fn some_zeros() {
                run_test_case(&"0".repeat(13), Ok(StarkHash([0; 32])));
            }

            #[test]
            fn short_odd() {
                let mut expected = [0; 32];
                expected[31] = 0x45;
                expected[30] = 0x23;
                expected[29] = 0x01;
                run_test_case("12345", Ok(StarkHash(expected)));
            }

            #[test]
            fn short_even() {
                let mut expected = [0; 32];
                expected[31] = 0x56;
                expected[30] = 0x34;
                expected[29] = 0x12;
                run_test_case("123456", Ok(StarkHash(expected)));
            }

            #[test]
            fn full() {
                let str = "0123456789ABCDEF0123456789abcdef0123456789ABCDEF0123456789abcdef";
                let expected = [
                    0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89,
                    0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23,
                    0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
                ];
                run_test_case(str, Ok(StarkHash(expected)));
            }

            #[test]
            fn full_odd() {
                let str = "123456789ABCDEF0123456789abcdef0123456789ABCDEF0123456789abcdef";
                let expected = [
                    0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89,
                    0xAB, 0xCD, 0xEF, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23,
                    0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
                ];
                run_test_case(str, Ok(StarkHash(expected)));
            }

            #[test]
            fn bad_length() {
                run_test_case(&"1".repeat(65), Err(HexParseError::Overflow));
            }

            #[test]
            fn overflow() {
                // correct byte length, but more than 251 bits.
                run_test_case(&"F".repeat(64), Err(HexParseError::Overflow));
            }
        }
    }
}
